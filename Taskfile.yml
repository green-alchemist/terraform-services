version: 3

vars:
  SERVICE_ENV_PAIRS:
    sh: |
      set -e
      echo "["
      for env_path in ./environments/*/; do
        if [ -d "$env_path" ]; then
          env=$(basename "$env_path")
          for service_path in "$env_path"*/; do
            if [ -d "$service_path" ] && [ -d "./services/$(basename "$service_path")" ]; then
              service=$(basename "$service_path")
              echo "{\"service\":\"$service\",\"env\":\"$env\"},"
            fi
          done
        fi
      done | sed '$s/,$//'
      echo "]"

  # Parses the JSON string into a structured list that Task can iterate over.
  PARSED_PAIRS:
    ref: fromJson .SERVICE_ENV_PAIRS
  CURRENT_BRANCH:
    sh: git rev-parse --abbrev-ref HEAD
  LOCAL_CHANGES:
    sh: git diff --name-only HEAD | awk -F'/' '/^services\// {print $2}' | LC_ALL=C sort -u | tr '\n' ' '
  UNPUSHED_COMMITS:
    sh: git diff --name-only origin/master...HEAD | awk -F'/' '/^services\// {print $2}' | sort -u | tr '\n' ' '
  IS_CI:
    sh: 'test -n "$CIRCLECI" && echo "true" || echo "false"'



  # Determines which services have changed. Adapts for CI vs. local environments.
  CHANGED_SERVICES:
    sh: |
      set -o pipefail
      CHANGED_FILES=""
      if [ -n "$CIRCLE_SHA1" ]; then
        CHANGED_FILES=$(git diff-tree --no-commit-id --name-only -r "$CIRCLE_SHA1")
      else
        CHANGED_FILES=$(git diff --name-only master...)
      fi

      if [ -n "$CHANGED_FILES" ]; then
        echo "$CHANGED_FILES" | \
        awk -F'/' '/^services\// {print $2}' | \
        grep -v '_bootstrap' | \
        sort -u | \
        while read -r service; do if [ -d "services/$service" ]; then echo "$service"; fi; done | \
        tr '\n' ' '
      else
        # If there are no changed files, output nothing and exit successfully.
        echo ""
      fi
    
  # Lists all available services based on the services/ directory.
  ALL_SERVICES:
    sh: find services -mindepth 1 -maxdepth 1 -type d -exec basename {} \; | LC_ALL=C sort | tr '\n' ' '


tasks:
  doc-root:
    desc: "Generates the root README.md file with a dynamic list of services."
    cmds:
      - task: _prompt-confirm
      - task: doc-root-header
      - for: { var: ALL_SERVICES }
        task: doc-root-service-link
        vars:
          SERVICE: '{{.ITEM}}'
      - task: doc-root-footer

  docs:
    desc: "Generates READMEs for all modules and a master index."
    cmds:
      - task: _prompt-confirm
      - task: doc-header
      - for: { var: ALL_SERVICES }
        task: doc-module
        vars:
          MODULE: '{{.ITEM}}'
      - task: doc-footer

  # --- Helper Tasks (internal) ---
  doc-root-header:
    internal: true
    cmds:
      - |
        echo -e "# Terraform Services Monorepo\n\nThis repository contains the Terraform configurations for managing the infrastructure of all services. It follows a monorepo pattern where each distinct piece of infrastructure (e.g., the Gatsby portfolio site, the Strapi CMS) is defined as a separate \"service.\"\n\nThe primary goal of this repository is to provide a centralized, version-controlled, and automated way to provision and manage cloud infrastructure on AWS.\n\n## Project Structure\n\nThe repository is organized into two main top-level directories:\n\n* **\`/services\`**: Contains the core Terraform code for each individual service. Each subdirectory represents a self-contained set of resources.\n* **\`/environments\`**: Contains the environment-specific configuration (\`.tfvars\` files) for each service. This is where you define the differences between environments like \`staging\` and \`production\` (e.g., instance sizes, domain names, etc.).\n\n## Available Services" > README.md

  doc-root-service-link:
    internal: true
    cmd: 'echo -e "* [\`{{.SERVICE}}\`](./services/{{.SERVICE}}/README.md)" >> README.md'
    requires:
      vars: [SERVICE]
  
  doc-root-footer:
    internal: true
    cmds:
      - |
        echo -e "\n## Local Development\n\nThis project uses [Task](https://taskfile.dev/) as a command runner to simplify common Terraform operations. The following commands are available to be run from the root of the repository.\n\n* \`task fmt\`: Formats all Terraform code recursively.\n* \`task validate-changed\`: Validates only the services that have been changed on your current branch compared to \`master\`.\n* \`task plan-changed\`: Creates a Terraform plan for the changed services against the \`staging\` environment by default.\n* \`task apply-changed\`: Applies the plan for the changed services. **Note:** This is typically handled by the CI/CD pipeline.\n* \`task clean\`: Removes all local Terraform cache files (\`.terraform\` directories and \`.tfplans\`).\n\nTo see a full list of available commands, run \`task --list-all\`.\n\n## CI/CD Automation with CircleCI\n\nThis repository is configured with a CircleCI pipeline (\`.circleci/config.yml\`) that automates the deployment of both infrastructure and applications. The pipeline is divided into distinct workflows to handle different scenarios." >> README.md

  doc-header:
    internal: true
    cmds:
      # Creates or overwrites the main README with a clean header
      - echo "# KC Terraform Services" > ./services/README.md
      - echo "" >> ./services/README.md

  doc-module:
    internal: true
    cmds:
      # 1. Appends the link for the current module to the main README
      - echo "* [{{.MODULE}}](./{{.MODULE}}/README.md)" >> ./services/README.md
      # 2. Runs terraform-docs to generate the specific module's documentation
      - echo "Generating docs for {{.MODULE}}..."
      - terraform-docs md table ./services/{{.MODULE}} > ./services/{{.MODULE}}/README.md
    requires:
      vars: [MODULE]

  doc-footer:
    internal: true
    cmds:
      # Appends a consistent footer to the main README
      - echo "## [Back](../README.md)" >> ./services/README.md
  
# End documentation functions

  default:
    cmds:
      - task --list-all

  print:
    desc: Print ALL SERVICES AND SERVICES
    cmds:
      - |
        echo "All Services: {{.ALL_SERVICES}}"
        echo "Chnaged Services: {{.CHANGED_SERVICES}}"
        echo "Local Chanegs: {{.LOCAL_CHANGES}}"
        echo "Unpushued Changes: {{.UNPUSHED_COMMITS}}"
        echo "Service env pairs: {{.SERVICE_ENV_PAIRS}}"
        echo "Parsed Pairs: {{.PARSED_PAIRS}}"
        

# --- CI/CD TASKS (for changed services) ---
  plan-local:
    desc: "Creates a Terraform plan for services with uncommitted local changes."
    preconditions:
      - sh: '[ -n "{{.LOCAL_CHANGES}}" ]'
        msg: "âœ… No uncommitted local changes detected in any services."
    cmds:
      - for: { var: LOCAL_CHANGES }
        task: plan-service
        vars:
          service: '{{.ITEM}}'
          env: '{{.env | default "staging"}}'
  
  validate-local:
    deps: [clean]
    desc: "Validates changed services (default env: staging)."
    preconditions:
      - sh: '[ -n "{{.LOCAL_CHANGES}}" ]'
        msg: "âœ… No uncommitted local changes detected in any services."
    cmds:
      - for: { var: LOCAL_CHANGES }
        task: validate-service
        vars:
          service: '{{.ITEM}}'
          env: '{{.env | default "staging"}}'

  plan-unpushed:
    desc: "Creates a Terraform plan for services with committed but unpushed changes."
    preconditions:
      - sh: '[ -n "{{.UNPUSHED_COMMITS}}" ]'
        msg: "âœ… No unpushed commits detected in any services."
    cmds:
      - for: { var: UNPUSHED_COMMITS }
        task: plan-service
        vars:
          service: '{{.ITEM}}'
          env: '{{.env | default "staging"}}'

  validate-changed:
    deps: [clean]
    desc: "Validates changed services (default env: staging)."
    cmds:
      - for: { var: CHANGED_SERVICES }
        task: validate-service
        vars:
          service: '{{.ITEM}}'
          env: '{{.env | default "staging"}}'

  plan-changed:
    desc: "Creates a Terraform plan for services that have changed since 'main'."
    # preconditions:
    #   - sh: '[ -n "{{.CHANGED_SERVICES}}" ]'
    #     msg: "âœ… No changed services detected. Nothing to plan."
    cmds:
      - for: { var: CHANGED_SERVICES }
        task: plan-service
        vars:
          service: '{{.ITEM}}'
          env: '{{.env | default "staging"}}'

  apply-changed:
    desc: "Applies the Terraform plan for changed services."
    # preconditions:
    #   - sh: '[ -n "{{.CHANGED_SERVICES}}" ]'
    #     msg: "âœ… No changed services detected. Nothing to apply."
    cmds:
      - for: { var: CHANGED_SERVICES }
        task: apply-service
        vars:
          service: '{{.ITEM}}'
          env: '{{.env | default "staging"}}'



  # --- MANUAL TASKS (for all services) ---

  init-all:
    deps: [clean]
    desc: "Initializes all environments for all services."
    cmds:
      - for: { var: PARSED_PAIRS }
        task: init-service
        vars:
          service: '{{.ITEM.service}}'
          env: '{{.ITEM.env}}'

  plan-all:
    desc: "Creates a Terraform plan for ALL services and environments."
    cmds:
      - for: { var: PARSED_PAIRS }
        task: plan-service
        vars: { service: '{{.ITEM.service}}', env: '{{.ITEM.env}}' }

  apply-all:
    desc: "Applies ALL planned changes for ALL services and environments."
    prompt: "Are you sure you want to apply ALL plans for ALL services and environments? [y/N]"
    cmds:
      - for: { var: PARSED_PAIRS }
        task: apply-service
        vars: { service: '{{.ITEM.service}}', env: '{{.ITEM.env}}' }

  validate-all:
    desc: "Validates all Terraform files in all services and environments"
    cmds:
      - for: { var: PARSED_PAIRS }
        task: validate-service
        vars:
          service: '{{.ITEM.service}}'
          env: '{{.ITEM.env}}'

# Utility ---------

  clean:
    desc: Remove terraform build files
    cmds:
      - find . -name .terraform | xargs rm -rf;
  
  clean-lock:
    desc: Remove terraform lock files
    cmds:
      - find . -type f -name ".terraform.lock.hcl" -delete

  fmt:
    desc: "Formats all Terraform files recursively"
    cmds:
      - terraform fmt -recursive

  destroy:
    desc: "DANGER: Destroys a SINGLE service in a specified environment."
    prompt: "ðŸ”´ Are you sure you want to destroy '{{.service}}' in '{{.env}}'? [y/N]"
    cmds:
      - task: destroy-service
        vars: { service: '{{.service}}', env: '{{.env}}' }
    requires:
      vars: [service, env]

  destroy-all:
    desc: "Destroys ALL infrastructure for a specific environment (defaults to staging)"
    prompt: "Are you sure you want to destroy ALL services in the {{.env | default \"staging\"}} environment? [y/N]"
    cmds:
      - for: { var: PARSED_PAIRS }
        # This will only destroy the services for the specified environment
        # Note: This is an improvement, as the old shell loop would have destroyed all environments.
        # We need a small check to ensure we only run on the correct env.
        # A direct way to handle this is to filter within the helper. Let's simplify the main task.
        task: destroy-service
        vars:
          service: '{{.ITEM.service}}'
          env: '{{.ITEM.env}}'


  # --- HELPER TASKS (internal) ---
  _prompt-confirm:
    internal: true
    cmds:
      - |
        if test {{.IS_CI}} = false; then
          printf "This will overwrite existing README files. Are you sure? [y/N] "
          read -r answer
          if [ "$answer" != "y" ] && [ "$answer" != "Y" ]; then
            echo "Aborted."
            exit 1
          fi
        fi
        
  init-service:
    internal: true
    cmds:
      - 'echo "--- Initializing: {{.service}} ({{.env}}) ---"'
      - terraform -chdir=./services/{{.service}}/ init -backend-config=../../environments/{{.env}}/{{.service}}/backend.tfvars
    requires:
      vars: [service, env]

  validate-service:
    deps:
      - task: init-service
        vars:
          service: "{{.service}}"
          env: "{{.env}}"
    internal: true
    cmds:
      - "echo --- Validating Service: {{.service}}, Environment: {{.env}} ---"
      - terraform -chdir=./services/{{.service}}/ validate
    requires:
      vars: [service, env]
      

  plan-service:
    internal: true
    deps:
      - task: init-service
        vars: { service: "{{.service}}", env: "{{.env}}" }
    cmds:
      - 'echo "--- Planning: {{.service}} ({{.env}}) ---"'
      - mkdir -p .tfplans/{{.env}}
      - |
        terraform -chdir=./services/{{.service}}/ plan \
          -var-file=../../environments/{{.env}}/{{.service}}/main.tfvars \
          -out=../../.tfplans/{{.env}}/{{.service}}.tfplan
    requires:
      vars: [service, env]

  apply-service:
    internal: true
    # No init needed here since we apply a plan file
    cmds:
      - 'echo "--- Applying: {{.service}} ({{.env}}) ---"'
      - terraform -chdir=./services/{{.service}}/ apply "../../.tfplans/{{.env}}/{{.service}}.tfplan"
    requires:
      vars: [service, env]

  destroy-service:
    internal: true
    deps:
      - task: init-service
        vars: { service: "{{.service}}", env: "{{.env}}" }
    cmds:
      - 'echo "--- Destroying: {{.service}} ({{.env}}) ---"'
      - |
        terraform -chdir=./services/{{.service}}/ destroy \
          -var-file=../../environments/{{.env}}/{{.service}}/main.tfvars \
          -auto-approve
    requires:
      vars: [service, env]